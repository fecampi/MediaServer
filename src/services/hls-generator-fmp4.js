const ffmpeg = require("fluent-ffmpeg");
const ffmpegInstaller = require("@ffmpeg-installer/ffmpeg");
const fs = require("fs");
const path = require("path");

ffmpeg.setFfmpegPath(ffmpegInstaller.path);

/**
 * Fun√ß√£o para gerar HLS com fMP4 a partir de um v√≠deo com m√∫ltiplas resolu√ß√µes
 * @param {string} inputFile Caminho do arquivo de entrada (v√≠deo)
 * @param {string} outputFolder Caminho da pasta de sa√≠da
 */
async function generateHLS_fMP4(inputFile, outputFolder) {
  console.log("üé¨ Iniciando processo de convers√£o HLS (fMP4)...");
  console.log(`üìÅ Arquivo de entrada: ${inputFile}`);
  // For√ßa sa√≠da para dist/hls
  const distHls = path.join(__dirname, '..', '..', 'dist', 'hls');
  let finalOutputFolder = outputFolder;
  if (!outputFolder.startsWith(distHls)) {
    // Se n√£o est√° em dist/hls, ajusta
    const baseName = path.basename(outputFolder);
    finalOutputFolder = path.join(distHls, baseName);
  }
  return new Promise((resolve, reject) => {
    ffmpeg(inputFile).ffprobe((err, metadata) => {
      if (err) {
        console.error("Erro ao obter metadados:", err);
        reject(err);
        return;
      }
      console.log("Metadados obtidos com sucesso!");
      // Obt√©m o primeiro fluxo de v√≠deo
      console.log("Procurando fluxo de v√≠deo nos metadados...");
      const videoStream = metadata.streams.find(
        (stream) => stream.codec_type === "video"
      );
      if (videoStream) {
        const width = videoStream.width;
        const height = videoStream.height;
        const duration = metadata.format.duration;
        const bitrate = metadata.format.bit_rate;

        console.log("Informa√ß√µes do v√≠deo original:");
        console.log(`   ‚Ä¢ Resolu√ß√£o: ${width}x${height}`);
        console.log(
          `   ‚Ä¢ Dura√ß√£o: ${duration ? Math.round(duration) : "N/A"} segundos`
        );
        console.log(
          `   ‚Ä¢ Bitrate: ${bitrate ? Math.round(bitrate / 1000) : "N/A"} kbps`
        );
        console.log(`   ‚Ä¢ Codec: ${videoStream.codec_name}`);

        // Resolu√ß√µes desejadas
        const resolutions = [
          { label: "1080p", width: 1920, height: 1080 },
          { label: "720p", width: 1280, height: 720 },
          { label: "480p", width: 854, height: 480 },
          { label: "360p", width: 640, height: 360 },
        ];

        console.log("Filtrando resolu√ß√µes compat√≠veis...");
        // Filtra as resolu√ß√µes que s√£o menores ou iguais √† resolu√ß√£o original
        const validResolutions = resolutions.filter(
          (resolution) =>
            resolution.width <= width && resolution.height <= height
        );

        console.log(
          "Resolu√ß√µes que ser√£o processadas: " +
            validResolutions.map((r) => r.label).join(", ")
        );

        // Usa diretamente a pasta de sa√≠da informada
        const outputVideoFolder = finalOutputFolder;
        console.log(`Usando pasta de sa√≠da: ${outputVideoFolder}`);
        if (!fs.existsSync(outputVideoFolder)) {
          fs.mkdirSync(outputVideoFolder, { recursive: true });
          console.log("Pasta de sa√≠da criada com sucesso!");
        } else {
          console.log("Pasta de sa√≠da j√° existe");
        }

        // Gerar fluxos de v√≠deo e arquivos .m3u8 para cada resolu√ß√£o
        console.log("Iniciando processamento das resolu√ß√µes...");
        let processedCount = 0;
        const totalResolutions = validResolutions.length;

        const videoStreams = validResolutions.map((resolution, index) => {
          return new Promise((resolve2, reject2) => {
            const outputFile = path.join(
              outputVideoFolder,
              `output_${resolution.label}.m3u8`
            );
            const segmentFile = path.join(
              outputVideoFolder,
              `output_${resolution.label}_%03d.m4s`
            );
            const initFile = path.join(
              outputVideoFolder,
              `init_${resolution.label}.mp4`
            );

            console.log(
              `Processando resolu√ß√£o ${resolution.label} (${
                index + 1
              }/${totalResolutions})`
            );
            console.log(`   Sa√≠da: ${path.basename(outputFile)}`);
            console.log(
              `   Resolu√ß√£o alvo: ${resolution.width}x${resolution.height}`
            );
            console.log(`   Formato: fMP4 (Fragmented MP4)`);

            const startTime = Date.now();

            ffmpeg(inputFile)
              .outputOptions([
                `-vf scale=${resolution.width}:${resolution.height}`, // Redimensionar para a resolu√ß√£o desejada
                "-c:v libx264",
                "-preset fast",
                "-crf 23",
                "-c:a aac",
                "-b:a 128k",
                "-f hls",
                "-hls_time 10",
                "-hls_list_size 0",
                "-hls_segment_type fmp4", // Usa fMP4 ao inv√©s de TS
                `-hls_fmp4_init_filename init_${resolution.label}.mp4`, // Arquivo de inicializa√ß√£o
                `-hls_segment_filename ${segmentFile}`,
                "-movflags +faststart", // Otimiza√ß√£o para streaming
                "-map 0:v:0",
                "-map 0:a:0?", // ? torna opcional
                "-map 0:a:1?",
                "-map 0:a:2?",
                "-map 0:a:3?",
                "-map 0:a:4?",
                "-map 0:a:5?",
              ])
              .output(outputFile)
              .on("start", (commandLine) => {
                console.log(`Comando FFmpeg iniciado para ${resolution.label}`);
                console.log(`   Comando: ${commandLine.substring(0, 100)}...`);
              })
              .on("progress", (progress) => {
                if (progress.percent) {
                  const percent = Math.round(progress.percent);
                  console.log(
                    `${resolution.label}: ${percent}% conclu√≠do (${
                      progress.currentFps || 0
                    } fps)`
                  );
                }
              })
              .on("end", () => {
                const endTime = Date.now();
                const duration = Math.round((endTime - startTime) / 1000);
                processedCount++;

                console.log(
                  `${resolution.label} processado com sucesso! (${duration}s)`
                );
                console.log(
                  `Progresso geral: ${processedCount}/${totalResolutions} resolu√ß√µes conclu√≠das`
                );
                resolve2();
              })
              .on("error", (err) => {
                console.error(
                  `Erro durante o processamento para ${resolution.label}: ${err.message}`
                );
                reject2(err);
              })
              .run();
          });
        });

        // Aguarda todos os v√≠deos serem gerados e cria o arquivo mestre M3U8
        console.log("Aguardando conclus√£o de todas as resolu√ß√µes...");
        const startTime = Date.now();
        Promise.all(videoStreams)
          .then(() => {
            const totalTime = Math.round((Date.now() - startTime) / 1000);
            console.log(
              `Todas as resolu√ß√µes processadas com sucesso! (Tempo total: ${totalTime}s)`
            );
            console.log("Criando arquivo mestre M3U8...");
            // Estimativas de largura de banda, average bandwidth, codecs e frame-rate para cada resolu√ß√£o
            const resolutionInfo = {
              "1080p": {
                bw: 4000000,
                avg: 3700000,
                codecs: "mp4a.40.2,avc1.640029",
                res: "1920x1080",
                fr: 30,
              },
              "720p": {
                bw: 2500000,
                avg: 2200000,
                codecs: "mp4a.40.2,avc1.64001F",
                res: "1280x720",
                fr: 30,
              },
              "480p": {
                bw: 1000000,
                avg: 900000,
                codecs: "mp4a.40.2,avc1.4d401e",
                res: "854x480",
                fr: 30,
              },
              "360p": {
                bw: 500000,
                avg: 400000,
                codecs: "mp4a.40.2,avc1.4d4015",
                res: "640x360",
                fr: 30,
              },
            };
            // Cabe√ßalho sem grupo de √°udio
            let masterFileContent =
              "#EXTM3U\n#EXT-X-VERSION:6\n## Gerado por express-hls-example\n\n# variants\n";
            // Variants (apenas v√≠deo+√°udio juntos)
            masterFileContent +=
              validResolutions
                .map((resolution) => {
                  const info = resolutionInfo[resolution.label];
                  return `#EXT-X-STREAM-INF:BANDWIDTH=${info.bw},AVERAGE-BANDWIDTH=${info.avg},CODECS=\"${info.codecs}\",RESOLUTION=${info.res},FRAME-RATE=${info.fr},CLOSED-CAPTIONS=NONE\noutput_${resolution.label}.m3u8`;
                })
                .join("\n") + "\n";
            // Cria o arquivo mestre M3U8
            const masterFile = path.join(outputVideoFolder, "master.m3u8");
            fs.writeFileSync(masterFile, masterFileContent);
            console.log("Arquivo mestre M3U8 gerado com sucesso!");
            console.log(`Arquivo criado: ${masterFile}`);
            console.log(
              "Processo de convers√£o HLS (fMP4) conclu√≠do com sucesso!"
            );
            console.log(`Estat√≠sticas finais:`);
            console.log(
              `   Resolu√ß√µes processadas: ${validResolutions.length}`
            );
            console.log(`   Tempo total: ${totalTime}s`);
            console.log(`   Formato: fMP4 (Fragmented MP4)`);
            console.log(`   Pasta de sa√≠da: ${outputVideoFolder}`);
            console.log("Vantagens do fMP4:");
            console.log("   Melhor compatibilidade com navegadores modernos");
            console.log(
              "   Suporte a recursos avan√ßados (CMAF, Low-Latency HLS)"
            );
            console.log("   Melhor integra√ß√£o com DRM");
            resolve();
          })
          .catch((err) => {
            console.error(
              "Erro durante a cria√ß√£o dos arquivos de v√≠deo HLS:",
              err.message
            );
            console.error(
              "Verifique se o arquivo de entrada existe e est√° acess√≠vel"
            );
            reject(err);
          });
      } else {
        console.error("Fluxo de v√≠deo n√£o encontrado nos metadados");
        console.log("Verifique se o arquivo √© um v√≠deo v√°lido");
        reject(new Error("Fluxo de v√≠deo n√£o encontrado nos metadados"));
      }
    });
  });
}
module.exports = { generateHLS_fMP4 };
